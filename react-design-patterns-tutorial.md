# Reactè®¾è®¡æ¨¡å¼å®Œæ•´æ•™ç¨‹

## ç›®å½•

1. [è®¾è®¡æ¨¡å¼ç®€ä»‹](#è®¾è®¡æ¨¡å¼ç®€ä»‹)
2. [ä¸ºä»€ä¹ˆReactå¼€å‘è€…éœ€è¦å­¦ä¹ è®¾è®¡æ¨¡å¼](#ä¸ºä»€ä¹ˆreactå¼€å‘è€…éœ€è¦å­¦ä¹ è®¾è®¡æ¨¡å¼)
3. [è®¾è®¡æ¨¡å¼åŸºç¡€](#è®¾è®¡æ¨¡å¼åŸºç¡€)
4. [åˆ›å»ºå‹æ¨¡å¼](#åˆ›å»ºå‹æ¨¡å¼)
   - [å·¥å‚æ¨¡å¼](#å·¥å‚æ¨¡å¼)
   - [å»ºé€ è€…æ¨¡å¼](#å»ºé€ è€…æ¨¡å¼)
   - [å•ä¾‹æ¨¡å¼](#å•ä¾‹æ¨¡å¼)
   - [åŸå‹æ¨¡å¼](#åŸå‹æ¨¡å¼)
5. [ç»“æ„å‹æ¨¡å¼](#ç»“æ„å‹æ¨¡å¼)
   - [é€‚é…å™¨æ¨¡å¼](#é€‚é…å™¨æ¨¡å¼)
   - [è£…é¥°å™¨æ¨¡å¼](#è£…é¥°å™¨æ¨¡å¼)
   - [å¤–è§‚æ¨¡å¼](#å¤–è§‚æ¨¡å¼)
   - [ä»£ç†æ¨¡å¼](#ä»£ç†æ¨¡å¼)
   - [ç»„åˆæ¨¡å¼](#ç»„åˆæ¨¡å¼)
6. [è¡Œä¸ºå‹æ¨¡å¼](#è¡Œä¸ºå‹æ¨¡å¼)
   - [è§‚å¯Ÿè€…æ¨¡å¼](#è§‚å¯Ÿè€…æ¨¡å¼)
   - [ç­–ç•¥æ¨¡å¼](#ç­–ç•¥æ¨¡å¼)
   - [å‘½ä»¤æ¨¡å¼](#å‘½ä»¤æ¨¡å¼)
   - [çŠ¶æ€æ¨¡å¼](#çŠ¶æ€æ¨¡å¼)
   - [è´£ä»»é“¾æ¨¡å¼](#è´£ä»»é“¾æ¨¡å¼)
7. [Reactç‰¹æœ‰æ¨¡å¼](#reactç‰¹æœ‰æ¨¡å¼)
   - [é«˜é˜¶ç»„ä»¶(HOC)](#é«˜é˜¶ç»„ä»¶hoc)
   - [Render Props](#render-props)
   - [è‡ªå®šä¹‰Hooksæ¨¡å¼](#è‡ªå®šä¹‰hooksæ¨¡å¼)
   - [ç»„åˆvsç»§æ‰¿](#ç»„åˆvsç»§æ‰¿)
   - [å—æ§vséå—æ§ç»„ä»¶](#å—æ§vséå—æ§ç»„ä»¶)
8. [é«˜çº§æ¨¡å¼](#é«˜çº§æ¨¡å¼)
   - [æä¾›è€…æ¨¡å¼](#æä¾›è€…æ¨¡å¼)
   - [å¤åˆç»„ä»¶æ¨¡å¼](#å¤åˆç»„ä»¶æ¨¡å¼)
   - [çŠ¶æ€ç¼©å‡å™¨æ¨¡å¼](#çŠ¶æ€ç¼©å‡å™¨æ¨¡å¼)
9. [æœ€ä½³å®è·µ](#æœ€ä½³å®è·µ)
10. [æ€»ç»“ä¸èµ„æº](#æ€»ç»“ä¸èµ„æº)

---

## è®¾è®¡æ¨¡å¼ç®€ä»‹

è®¾è®¡æ¨¡å¼æ˜¯è§£å†³è½¯ä»¶è®¾è®¡ä¸­å¸¸è§é—®é¢˜çš„å¯é‡ç”¨è§£å†³æ–¹æ¡ˆã€‚å®ƒä»¬æ˜¯ç»è¿‡éªŒè¯çš„æœ€ä½³å®è·µï¼Œèƒ½å¤Ÿå¸®åŠ©å¼€å‘è€…ç¼–å†™æ›´æ¸…æ™°ã€æ›´çµæ´»ã€æ›´å¯ç»´æŠ¤çš„ä»£ç ã€‚

### è®¾è®¡æ¨¡å¼çš„æ ¸å¿ƒåŸåˆ™

1. **å¼€é—­åŸåˆ™**: å¯¹æ‰©å±•å¼€æ”¾ï¼Œå¯¹ä¿®æ”¹å…³é—­
2. **å•ä¸€èŒè´£åŸåˆ™**: ä¸€ä¸ªç±»åº”è¯¥åªæœ‰ä¸€ä¸ªæ”¹å˜çš„ç†ç”±
3. **ä¾èµ–å€’ç½®åŸåˆ™**: ä¾èµ–äºæŠ½è±¡ï¼Œä¸ä¾èµ–äºå…·ä½“å®ç°
4. **é‡Œæ°æ›¿æ¢åŸåˆ™**: å­ç±»å¿…é¡»èƒ½å¤Ÿæ›¿æ¢å…¶åŸºç±»
5. **æ¥å£éš”ç¦»åŸåˆ™**: å®¢æˆ·ç«¯ä¸åº”è¯¥ä¾èµ–å®ƒä¸éœ€è¦çš„æ¥å£

---

## ä¸ºä»€ä¹ˆReactå¼€å‘è€…éœ€è¦å­¦ä¹ è®¾è®¡æ¨¡å¼

### 1. ç»„ä»¶å¤ç”¨æ€§
è®¾è®¡æ¨¡å¼å¸®åŠ©åˆ›å»ºå¯é‡ç”¨çš„ç»„ä»¶ï¼Œå‡å°‘ä»£ç é‡å¤ã€‚

### 2. ä»£ç å¯ç»´æŠ¤æ€§
è‰¯å¥½çš„æ¨¡å¼ä½¿ä»£ç ç»“æ„æ¸…æ™°ï¼Œä¾¿äºç»´æŠ¤å’Œè°ƒè¯•ã€‚

### 3. å›¢é˜Ÿåä½œ
æ ‡å‡†åŒ–çš„æ¨¡å¼è®©å›¢é˜Ÿæˆå‘˜æ›´å®¹æ˜“ç†è§£ä»£ç ç»“æ„ã€‚

### 4. æ€§èƒ½ä¼˜åŒ–
æŸäº›æ¨¡å¼èƒ½å¤Ÿå¸®åŠ©ä¼˜åŒ–Reactåº”ç”¨çš„æ€§èƒ½ã€‚

### 5. æ¶æ„è®¾è®¡
æ¨¡å¼æä¾›äº†æ„å»ºå¤§å‹åº”ç”¨çš„æ¶æ„æŒ‡å¯¼ã€‚

---

## è®¾è®¡æ¨¡å¼åŸºç¡€

### æ¨¡å¼åˆ†ç±»

- **åˆ›å»ºå‹æ¨¡å¼**: å¤„ç†å¯¹è±¡åˆ›å»º
- **ç»“æ„å‹æ¨¡å¼**: å¤„ç†å¯¹è±¡ç»„åˆ
- **è¡Œä¸ºå‹æ¨¡å¼**: å¤„ç†å¯¹è±¡é—´çš„äº¤äº’

---

## åˆ›å»ºå‹æ¨¡å¼

### å·¥å‚æ¨¡å¼

å·¥å‚æ¨¡å¼ç”¨äºåˆ›å»ºå¯¹è±¡è€Œä¸æŒ‡å®šç¡®åˆ‡çš„ç±»ã€‚

```jsx
// ç»„ä»¶å·¥å‚
const ComponentFactory = {
  createButton: (props) => {
    switch (props.type) {
      case 'primary':
        return <PrimaryButton {...props} />;
      case 'secondary':
        return <SecondaryButton {...props} />;
      case 'danger':
        return <DangerButton {...props} />;
      default:
        return <DefaultButton {...props} />;
    }
  },
  
  createInput: (props) => {
    switch (props.type) {
      case 'text':
        return <TextInput {...props} />;
      case 'email':
        return <EmailInput {...props} />;
      case 'password':
        return <PasswordInput {...props} />;
      default:
        return <DefaultInput {...props} />;
    }
  }
};

// ä½¿ç”¨å·¥å‚
const MyForm = () => {
  return (
    <form>
      {ComponentFactory.createInput({ type: 'email', placeholder: 'Email' })}
      {ComponentFactory.createInput({ type: 'password', placeholder: 'Password' })}
      {ComponentFactory.createButton({ type: 'primary', children: 'Login' })}
    </form>
  );
};
```

### å»ºé€ è€…æ¨¡å¼

å»ºé€ è€…æ¨¡å¼ç”¨äºæ„å»ºå¤æ‚å¯¹è±¡ã€‚

```jsx
// è¡¨å•å»ºé€ è€…
class FormBuilder {
  constructor() {
    this.fields = [];
    this.actions = [];
    this.validation = {};
  }
  
  addField(type, name, props = {}) {
    this.fields.push({ type, name, props });
    return this;
  }
  
  addValidation(field, rules) {
    this.validation[field] = rules;
    return this;
  }
  
  addAction(type, text, handler) {
    this.actions.push({ type, text, handler });
    return this;
  }
  
  build() {
    return (
      <Form 
        fields={this.fields}
        actions={this.actions}
        validation={this.validation}
      />
    );
  }
}

// ä½¿ç”¨å»ºé€ è€…
const loginForm = new FormBuilder()
  .addField('email', 'email', { placeholder: 'Enter email' })
  .addField('password', 'password', { placeholder: 'Enter password' })
  .addValidation('email', { required: true, email: true })
  .addValidation('password', { required: true, minLength: 6 })
  .addAction('submit', 'Login', handleLogin)
  .addAction('button', 'Cancel', handleCancel)
  .build();
```

### å•ä¾‹æ¨¡å¼

ç¡®ä¿ä¸€ä¸ªç±»åªæœ‰ä¸€ä¸ªå®ä¾‹ã€‚

```jsx
// APIå®¢æˆ·ç«¯å•ä¾‹
class ApiClient {
  constructor() {
    if (ApiClient.instance) {
      return ApiClient.instance;
    }
    
    this.baseURL = process.env.REACT_APP_API_URL;
    this.token = null;
    ApiClient.instance = this;
  }
  
  setToken(token) {
    this.token = token;
  }
  
  async request(endpoint, options = {}) {
    const url = `${this.baseURL}${endpoint}`;
    const config = {
      ...options,
      headers: {
        'Content-Type': 'application/json',
        ...(this.token && { Authorization: `Bearer ${this.token}` }),
        ...options.headers,
      },
    };
    
    return fetch(url, config);
  }
}

// ä½¿ç”¨å•ä¾‹
const api = new ApiClient();

// åœ¨ä»»ä½•åœ°æ–¹ä½¿ç”¨
const UserProfile = () => {
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    api.request('/user/profile')
      .then(response => response.json())
      .then(setUser);
  }, []);
  
  return <div>{user?.name}</div>;
};
```

### åŸå‹æ¨¡å¼

é€šè¿‡å…‹éš†ç°æœ‰å¯¹è±¡åˆ›å»ºæ–°å¯¹è±¡ã€‚

```jsx
// ç»„ä»¶é…ç½®åŸå‹
const baseComponentConfig = {
  theme: 'light',
  size: 'medium',
  disabled: false,
  loading: false,
};

// å…‹éš†å¹¶æ‰©å±•é…ç½®
const createButtonConfig = (overrides = {}) => ({
  ...baseComponentConfig,
  type: 'button',
  variant: 'primary',
  ...overrides,
});

const createInputConfig = (overrides = {}) => ({
  ...baseComponentConfig,
  type: 'input',
  variant: 'outlined',
  ...overrides,
});

// ä½¿ç”¨åŸå‹
const primaryButton = createButtonConfig({ variant: 'primary' });
const dangerButton = createButtonConfig({ variant: 'danger', size: 'large' });
```

---

## ç»“æ„å‹æ¨¡å¼

### é€‚é…å™¨æ¨¡å¼

é€‚é…å™¨æ¨¡å¼å…è®¸ä¸å…¼å®¹çš„æ¥å£ååŒå·¥ä½œã€‚

```jsx
// æ—§çš„APIå“åº”æ ¼å¼
const oldApiResponse = {
  user_name: 'John Doe',
  user_email: 'john@example.com',
  user_id: 123,
};

// æ–°çš„ç»„ä»¶æœŸæœ›çš„æ ¼å¼
const expectedFormat = {
  name: 'John Doe',
  email: 'john@example.com',
  id: 123,
};

// é€‚é…å™¨
const userDataAdapter = (oldData) => ({
  name: oldData.user_name,
  email: oldData.user_email,
  id: oldData.user_id,
});

// é«˜é˜¶ç»„ä»¶é€‚é…å™¨
const withDataAdapter = (WrappedComponent, adapter) => {
  return (props) => {
    const adaptedData = adapter(props.data);
    return <WrappedComponent {...props} data={adaptedData} />;
  };
};

// ä½¿ç”¨é€‚é…å™¨
const UserCard = ({ data }) => (
  <div>
    <h3>{data.name}</h3>
    <p>{data.email}</p>
  </div>
);

const AdaptedUserCard = withDataAdapter(UserCard, userDataAdapter);
```

### è£…é¥°å™¨æ¨¡å¼

è£…é¥°å™¨æ¨¡å¼åŠ¨æ€åœ°ç»™å¯¹è±¡æ·»åŠ é¢å¤–çš„åŠŸèƒ½ã€‚

```jsx
// åŸºç¡€ç»„ä»¶
const BaseButton = ({ children, ...props }) => (
  <button {...props}>{children}</button>
);

// è£…é¥°å™¨HOCs
const withLoading = (WrappedComponent) => {
  return ({ loading, children, ...props }) => {
    if (loading) {
      return <WrappedComponent {...props}>Loading...</WrappedComponent>;
    }
    return <WrappedComponent {...props}>{children}</WrappedComponent>;
  };
};

const withAnalytics = (WrappedComponent) => {
  return ({ trackingId, ...props }) => {
    const handleClick = (e) => {
      if (trackingId) {
        analytics.track(trackingId, { event: 'button_click' });
      }
      props.onClick?.(e);
    };
    
    return <WrappedComponent {...props} onClick={handleClick} />;
  };
};

const withTooltip = (WrappedComponent) => {
  return ({ tooltip, ...props }) => (
    <div title={tooltip}>
      <WrappedComponent {...props} />
    </div>
  );
};

// ç»„åˆè£…é¥°å™¨
const EnhancedButton = withTooltip(
  withAnalytics(
    withLoading(BaseButton)
  )
);

// ä½¿ç”¨
<EnhancedButton
  loading={isLoading}
  trackingId="login-button"
  tooltip="Click to login"
  onClick={handleLogin}
>
  Login
</EnhancedButton>
```

### å¤–è§‚æ¨¡å¼

å¤–è§‚æ¨¡å¼æä¾›ç»Ÿä¸€çš„æ¥å£æ¥è®¿é—®å¤æ‚çš„å­ç³»ç»Ÿã€‚

```jsx
// å¤æ‚çš„å­ç³»ç»Ÿ
class ValidationService {
  validateEmail(email) {
    return /\S+@\S+\.\S+/.test(email);
  }
  
  validatePassword(password) {
    return password.length >= 8;
  }
}

class ApiService {
  async login(credentials) {
    return fetch('/api/login', {
      method: 'POST',
      body: JSON.stringify(credentials),
    });
  }
}

class AuthService {
  setToken(token) {
    localStorage.setItem('token', token);
  }
  
  getToken() {
    return localStorage.getItem('token');
  }
}

// å¤–è§‚ç±»
class AuthFacade {
  constructor() {
    this.validation = new ValidationService();
    this.api = new ApiService();
    this.auth = new AuthService();
  }
  
  async login(email, password) {
    // éªŒè¯
    if (!this.validation.validateEmail(email)) {
      throw new Error('Invalid email');
    }
    
    if (!this.validation.validatePassword(password)) {
      throw new Error('Password must be at least 8 characters');
    }
    
    // ç™»å½•
    const response = await this.api.login({ email, password });
    const data = await response.json();
    
    // ä¿å­˜token
    this.auth.setToken(data.token);
    
    return data.user;
  }
}

// Reactç»„ä»¶ä¸­ä½¿ç”¨å¤–è§‚
const LoginForm = () => {
  const [credentials, setCredentials] = useState({ email: '', password: '' });
  const authFacade = useMemo(() => new AuthFacade(), []);
  
  const handleSubmit = async (e) => {
    e.preventDefault();
    try {
      const user = await authFacade.login(credentials.email, credentials.password);
      console.log('Login successful:', user);
    } catch (error) {
      console.error('Login failed:', error.message);
    }
  };
  
  return (
    <form onSubmit={handleSubmit}>
      {/* è¡¨å•å­—æ®µ */}
    </form>
  );
};
```

### ä»£ç†æ¨¡å¼

ä»£ç†æ¨¡å¼ä¸ºå…¶ä»–å¯¹è±¡æä¾›ä»£ç†ä»¥æ§åˆ¶å¯¹å®ƒçš„è®¿é—®ã€‚

```jsx
// å›¾ç‰‡æ‡’åŠ è½½ä»£ç†
const LazyImage = ({ src, alt, placeholder, ...props }) => {
  const [imageSrc, setImageSrc] = useState(placeholder);
  const [isLoaded, setIsLoaded] = useState(false);
  const imgRef = useRef();
  
  useEffect(() => {
    const observer = new IntersectionObserver(
      ([entry]) => {
        if (entry.isIntersecting && !isLoaded) {
          setImageSrc(src);
          setIsLoaded(true);
          observer.disconnect();
        }
      },
      { threshold: 0.1 }
    );
    
    if (imgRef.current) {
      observer.observe(imgRef.current);
    }
    
    return () => observer.disconnect();
  }, [src, isLoaded]);
  
  return (
    <img
      ref={imgRef}
      src={imageSrc}
      alt={alt}
      {...props}
    />
  );
};

// APIç¼“å­˜ä»£ç†
class CachedApiProxy {
  constructor(apiService) {
    this.apiService = apiService;
    this.cache = new Map();
  }
  
  async get(url, options = {}) {
    const cacheKey = `${url}:${JSON.stringify(options)}`;
    
    if (this.cache.has(cacheKey)) {
      return this.cache.get(cacheKey);
    }
    
    const response = await this.apiService.get(url, options);
    this.cache.set(cacheKey, response);
    
    // è®¾ç½®ç¼“å­˜è¿‡æœŸ
    setTimeout(() => {
      this.cache.delete(cacheKey);
    }, 5 * 60 * 1000); // 5åˆ†é’Ÿ
    
    return response;
  }
}
```

### ç»„åˆæ¨¡å¼

ç»„åˆæ¨¡å¼å°†å¯¹è±¡ç»„åˆæˆæ ‘å½¢ç»“æ„ä»¥è¡¨ç¤º"éƒ¨åˆ†-æ•´ä½“"çš„å±‚æ¬¡ç»“æ„ã€‚

```jsx
// èœå•ç»„åˆæ¨¡å¼
const MenuItem = ({ children, icon, onClick }) => (
  <div className="menu-item" onClick={onClick}>
    {icon && <span className="icon">{icon}</span>}
    <span>{children}</span>
  </div>
);

const MenuGroup = ({ title, children }) => (
  <div className="menu-group">
    <div className="menu-group-title">{title}</div>
    <div className="menu-group-content">{children}</div>
  </div>
);

const Menu = ({ children }) => (
  <div className="menu">{children}</div>
);

// ä½¿ç”¨ç»„åˆ
const AppMenu = () => (
  <Menu>
    <MenuGroup title="Dashboard">
      <MenuItem icon="ğŸ“Š" onClick={() => navigate('/dashboard')}>
        Overview
      </MenuItem>
      <MenuItem icon="ğŸ“ˆ" onClick={() => navigate('/analytics')}>
        Analytics
      </MenuItem>
    </MenuGroup>
    
    <MenuGroup title="Users">
      <MenuItem icon="ğŸ‘¤" onClick={() => navigate('/users')}>
        All Users
      </MenuItem>
      <MenuItem icon="â•" onClick={() => navigate('/users/new')}>
        Add User
      </MenuItem>
    </MenuGroup>
    
    <MenuItem icon="âš™ï¸" onClick={() => navigate('/settings')}>
      Settings
    </MenuItem>
  </Menu>
);
```

---

## è¡Œä¸ºå‹æ¨¡å¼

### è§‚å¯Ÿè€…æ¨¡å¼

è§‚å¯Ÿè€…æ¨¡å¼å®šä¹‰å¯¹è±¡é—´çš„ä¸€å¯¹å¤šä¾èµ–å…³ç³»ã€‚

```jsx
// äº‹ä»¶ç®¡ç†å™¨
class EventManager {
  constructor() {
    this.listeners = {};
  }
  
  subscribe(event, callback) {
    if (!this.listeners[event]) {
      this.listeners[event] = [];
    }
    this.listeners[event].push(callback);
    
    // è¿”å›å–æ¶ˆè®¢é˜…å‡½æ•°
    return () => {
      this.listeners[event] = this.listeners[event].filter(cb => cb !== callback);
    };
  }
  
  emit(event, data) {
    if (this.listeners[event]) {
      this.listeners[event].forEach(callback => callback(data));
    }
  }
}

// å…¨å±€äº‹ä»¶ç®¡ç†å™¨
const eventManager = new EventManager();

// è‡ªå®šä¹‰Hook
const useEvent = (event, callback) => {
  useEffect(() => {
    return eventManager.subscribe(event, callback);
  }, [event, callback]);
};

const useEmitEvent = () => {
  return useCallback((event, data) => {
    eventManager.emit(event, data);
  }, []);
};

// ä½¿ç”¨ç¤ºä¾‹
const UserProfile = () => {
  const [user, setUser] = useState(null);
  const emit = useEmitEvent();
  
  useEvent('user:updated', (updatedUser) => {
    setUser(updatedUser);
  });
  
  const handleUpdate = (userData) => {
    // æ›´æ–°ç”¨æˆ·åé€šçŸ¥å…¶ä»–ç»„ä»¶
    emit('user:updated', userData);
  };
  
  return <div>{/* ç”¨æˆ·ç•Œé¢ */}</div>;
};

const Notification = () => {
  const [message, setMessage] = useState('');
  
  useEvent('user:updated', (user) => {
    setMessage(`ç”¨æˆ· ${user.name} å·²æ›´æ–°`);
  });
  
  return message ? <div className="notification">{message}</div> : null;
};
```

### ç­–ç•¥æ¨¡å¼

ç­–ç•¥æ¨¡å¼å®šä¹‰ä¸€ç³»åˆ—ç®—æ³•ï¼Œå¹¶ä½¿å®ƒä»¬å¯ä»¥äº’æ¢ã€‚

```jsx
// æ’åºç­–ç•¥
const sortStrategies = {
  name: (a, b) => a.name.localeCompare(b.name),
  date: (a, b) => new Date(a.date) - new Date(b.date),
  price: (a, b) => a.price - b.price,
  rating: (a, b) => b.rating - a.rating,
};

// è¿‡æ»¤ç­–ç•¥
const filterStrategies = {
  all: () => true,
  active: (item) => item.status === 'active',
  inactive: (item) => item.status === 'inactive',
  featured: (item) => item.featured === true,
};

// ä½¿ç”¨ç­–ç•¥çš„ç»„ä»¶
const ProductList = ({ products }) => {
  const [sortBy, setSortBy] = useState('name');
  const [filterBy, setFilterBy] = useState('all');
  
  const processedProducts = useMemo(() => {
    const filtered = products.filter(filterStrategies[filterBy]);
    return filtered.sort(sortStrategies[sortBy]);
  }, [products, sortBy, filterBy]);
  
  return (
    <div>
      <div className="controls">
        <select value={sortBy} onChange={e => setSortBy(e.target.value)}>
          <option value="name">æŒ‰åç§°æ’åº</option>
          <option value="date">æŒ‰æ—¥æœŸæ’åº</option>
          <option value="price">æŒ‰ä»·æ ¼æ’åº</option>
          <option value="rating">æŒ‰è¯„çº§æ’åº</option>
        </select>
        
        <select value={filterBy} onChange={e => setFilterBy(e.target.value)}>
          <option value="all">æ‰€æœ‰äº§å“</option>
          <option value="active">æ´»è·ƒäº§å“</option>
          <option value="inactive">éæ´»è·ƒäº§å“</option>
          <option value="featured">ç‰¹è‰²äº§å“</option>
        </select>
      </div>
      
      <div className="product-grid">
        {processedProducts.map(product => (
          <ProductCard key={product.id} product={product} />
        ))}
      </div>
    </div>
  );
};
```

### å‘½ä»¤æ¨¡å¼

å‘½ä»¤æ¨¡å¼å°†è¯·æ±‚å°è£…ä¸ºå¯¹è±¡ã€‚

```jsx
// å‘½ä»¤æ¥å£
class Command {
  execute() {
    throw new Error('Execute method must be implemented');
  }
  
  undo() {
    throw new Error('Undo method must be implemented');
  }
}

// å…·ä½“å‘½ä»¤
class AddTodoCommand extends Command {
  constructor(todoList, todo) {
    super();
    this.todoList = todoList;
    this.todo = todo;
  }
  
  execute() {
    this.todoList.add(this.todo);
  }
  
  undo() {
    this.todoList.remove(this.todo.id);
  }
}

class RemoveTodoCommand extends Command {
  constructor(todoList, todoId) {
    super();
    this.todoList = todoList;
    this.todoId = todoId;
    this.removedTodo = null;
  }
  
  execute() {
    this.removedTodo = this.todoList.findById(this.todoId);
    this.todoList.remove(this.todoId);
  }
  
  undo() {
    if (this.removedTodo) {
      this.todoList.add(this.removedTodo);
    }
  }
}

// å‘½ä»¤ç®¡ç†å™¨
class CommandManager {
  constructor() {
    this.history = [];
    this.currentIndex = -1;
  }
  
  execute(command) {
    command.execute();
    
    // ç§»é™¤å½“å‰ä½ç½®ä¹‹åçš„å‘½ä»¤
    this.history.splice(this.currentIndex + 1);
    this.history.push(command);
    this.currentIndex++;
  }
  
  undo() {
    if (this.currentIndex >= 0) {
      const command = this.history[this.currentIndex];
      command.undo();
      this.currentIndex--;
    }
  }
  
  redo() {
    if (this.currentIndex < this.history.length - 1) {
      this.currentIndex++;
      const command = this.history[this.currentIndex];
      command.execute();
    }
  }
}

// Reactä¸­ä½¿ç”¨å‘½ä»¤æ¨¡å¼
const TodoApp = () => {
  const [todos, setTodos] = useState([]);
  const commandManager = useRef(new CommandManager());
  
  const todoList = {
    add: (todo) => setTodos(prev => [...prev, todo]),
    remove: (id) => setTodos(prev => prev.filter(t => t.id !== id)),
    findById: (id) => todos.find(t => t.id === id),
  };
  
  const addTodo = (todo) => {
    const command = new AddTodoCommand(todoList, todo);
    commandManager.current.execute(command);
  };
  
  const removeTodo = (id) => {
    const command = new RemoveTodoCommand(todoList, id);
    commandManager.current.execute(command);
  };
  
  const undo = () => commandManager.current.undo();
  const redo = () => commandManager.current.redo();
  
  return (
    <div>
      <div className="toolbar">
        <button onClick={undo}>æ’¤é”€</button>
        <button onClick={redo}>é‡åš</button>
      </div>
      {/* Todoåˆ—è¡¨ */}
    </div>
  );
};
```

### çŠ¶æ€æ¨¡å¼

çŠ¶æ€æ¨¡å¼å…è®¸å¯¹è±¡åœ¨å†…éƒ¨çŠ¶æ€æ”¹å˜æ—¶æ”¹å˜å®ƒçš„è¡Œä¸ºã€‚

```jsx
// çŠ¶æ€æ¥å£
class State {
  handle(context) {
    throw new Error('Handle method must be implemented');
  }
}

// å…·ä½“çŠ¶æ€
class LoadingState extends State {
  handle(context) {
    return (
      <div className="loading">
        <Spinner />
        <p>åŠ è½½ä¸­...</p>
      </div>
    );
  }
}

class SuccessState extends State {
  constructor(data) {
    super();
    this.data = data;
  }
  
  handle(context) {
    return (
      <div className="success">
        <h2>åŠ è½½æˆåŠŸ</h2>
        <DataDisplay data={this.data} />
        <button onClick={() => context.setState(new LoadingState())}>
          åˆ·æ–°
        </button>
      </div>
    );
  }
}

class ErrorState extends State {
  constructor(error) {
    super();
    this.error = error;
  }
  
  handle(context) {
    return (
      <div className="error">
        <h2>åŠ è½½å¤±è´¥</h2>
        <p>{this.error.message}</p>
        <button onClick={() => context.setState(new LoadingState())}>
          é‡è¯•
        </button>
      </div>
    );
  }
}

class IdleState extends State {
  handle(context) {
    return (
      <div className="idle">
        <h2>å‡†å¤‡åŠ è½½</h2>
        <button onClick={() => context.setState(new LoadingState())}>
          å¼€å§‹åŠ è½½
        </button>
      </div>
    );
  }
}

// çŠ¶æ€ä¸Šä¸‹æ–‡
const useStateMachine = (initialState) => {
  const [state, setState] = useState(initialState);
  
  const context = {
    setState,
    render: () => state.handle(context),
  };
  
  return context;
};

// ä½¿ç”¨çŠ¶æ€æœº
const DataComponent = () => {
  const stateMachine = useStateMachine(new IdleState());
  
  useEffect(() => {
    // ç›‘å¬çŠ¶æ€å˜åŒ–ï¼Œæ‰§è¡Œç›¸åº”æ“ä½œ
    if (stateMachine.state instanceof LoadingState) {
      fetchData()
        .then(data => stateMachine.setState(new SuccessState(data)))
        .catch(error => stateMachine.setState(new ErrorState(error)));
    }
  }, [stateMachine.state]);
  
  return stateMachine.render();
};
```

### è´£ä»»é“¾æ¨¡å¼

è´£ä»»é“¾æ¨¡å¼ä¸ºè¯·æ±‚åˆ›å»ºæ¥æ”¶è€…å¯¹è±¡çš„é“¾ã€‚

```jsx
// å¤„ç†å™¨æŠ½è±¡ç±»
class Handler {
  constructor() {
    this.nextHandler = null;
  }
  
  setNext(handler) {
    this.nextHandler = handler;
    return handler;
  }
  
  handle(request) {
    if (this.canHandle(request)) {
      return this.process(request);
    }
    
    if (this.nextHandler) {
      return this.nextHandler.handle(request);
    }
    
    return null;
  }
  
  canHandle(request) {
    throw new Error('canHandle method must be implemented');
  }
  
  process(request) {
    throw new Error('process method must be implemented');
  }
}

// å…·ä½“å¤„ç†å™¨
class AuthHandler extends Handler {
  canHandle(request) {
    return !request.user;
  }
  
  process(request) {
    return { error: 'Authentication required', redirect: '/login' };
  }
}

class PermissionHandler extends Handler {
  canHandle(request) {
    return request.user && !request.user.hasPermission(request.resource);
  }
  
  process(request) {
    return { error: 'Permission denied', status: 403 };
  }
}

class ValidationHandler extends Handler {
  canHandle(request) {
    return request.data && !this.validateData(request.data);
  }
  
  process(request) {
    return { error: 'Invalid data', validationErrors: this.getErrors(request.data) };
  }
  
  validateData(data) {
    // éªŒè¯é€»è¾‘
    return true;
  }
  
  getErrors(data) {
    // è·å–é”™è¯¯ä¿¡æ¯
    return [];
  }
}

class ProcessHandler extends Handler {
  canHandle(request) {
    return true; // æ€»æ˜¯å¯ä»¥å¤„ç†
  }
  
  process(request) {
    // å®é™…å¤„ç†ä¸šåŠ¡é€»è¾‘
    return { success: true, data: request.data };
  }
}

// è®¾ç½®è´£ä»»é“¾
const createHandlerChain = () => {
  const authHandler = new AuthHandler();
  const permissionHandler = new PermissionHandler();
  const validationHandler = new ValidationHandler();
  const processHandler = new ProcessHandler();
  
  authHandler
    .setNext(permissionHandler)
    .setNext(validationHandler)
    .setNext(processHandler);
    
  return authHandler;
};

// Reactä¸­ä½¿ç”¨è´£ä»»é“¾
const useRequestHandler = () => {
  const handlerChain = useMemo(() => createHandlerChain(), []);
  
  return useCallback((request) => {
    return handlerChain.handle(request);
  }, [handlerChain]);
};

const ApiForm = () => {
  const handleRequest = useRequestHandler();
  const [result, setResult] = useState(null);
  
  const onSubmit = (data) => {
    const request = {
      user: getCurrentUser(),
      resource: 'api/data',
      data,
    };
    
    const response = handleRequest(request);
    setResult(response);
  };
  
  return (
    <div>
      {/* è¡¨å•ç»„ä»¶ */}
      {result && (
        <div className={result.error ? 'error' : 'success'}>
          {result.error || 'Success!'}
        </div>
      )}
    </div>
  );
};
```

---

## Reactç‰¹æœ‰æ¨¡å¼

### é«˜é˜¶ç»„ä»¶(HOC)

é«˜é˜¶ç»„ä»¶æ˜¯å‚æ•°ä¸ºç»„ä»¶ï¼Œè¿”å›å€¼ä¸ºæ–°ç»„ä»¶çš„å‡½æ•°ã€‚

```jsx
// åŸºç¡€HOC
const withLoading = (WrappedComponent) => {
  return (props) => {
    if (props.loading) {
      return <div>Loading...</div>;
    }
    return <WrappedComponent {...props} />;
  };
};

// å¤æ‚HOCç¤ºä¾‹
const withAuth = (WrappedComponent, options = {}) => {
  const { redirectTo = '/login', requiredRole = null } = options;
  
  return (props) => {
    const { user, isAuthenticated } = useAuth();
    
    if (!isAuthenticated) {
      return <Redirect to={redirectTo} />;
    }
    
    if (requiredRole && !user.roles.includes(requiredRole)) {
      return <div>Access Denied</div>;
    }
    
    return <WrappedComponent {...props} user={user} />;
  };
};

// æ•°æ®è·å–HOC
const withData = (WrappedComponent, dataSource) => {
  return (props) => {
    const [data, setData] = useState(null);
    const [loading, setLoading] = useState(true);
    const [error, setError] = useState(null);
    
    useEffect(() => {
      setLoading(true);
      dataSource(props)
        .then(setData)
        .catch(setError)
        .finally(() => setLoading(false));
    }, []);
    
    return (
      <WrappedComponent
        {...props}
        data={data}
        loading={loading}
        error={error}
      />
    );
  };
};

// ç»„åˆHOC
const enhance = compose(
  withAuth({ requiredRole: 'admin' }),
  withData(fetchUserData),
  withLoading
);

const UserDashboard = enhance(({ data, user }) => (
  <div>
    <h1>Welcome, {user.name}</h1>
    <UserList users={data} />
  </div>
));
```

### Render Props

Render Propsæ˜¯æŒ‡ä¸€ç§åœ¨Reactç»„ä»¶ä¹‹é—´ä½¿ç”¨å‡½æ•°propå…±äº«ä»£ç çš„æŠ€æœ¯ã€‚

```jsx
// åŸºç¡€Render Props
const MouseTracker = ({ render }) => {
  const [position, setPosition] = useState({ x: 0, y: 0 });
  
  useEffect(() => {
    const handleMouseMove = (e) => {
      setPosition({ x: e.clientX, y: e.clientY });
    };
    
    window.addEventListener('mousemove', handleMouseMove);
    return () => window.removeEventListener('mousemove', handleMouseMove);
  }, []);
  
  return render(position);
};

// ä½¿ç”¨Render Props
const App = () => (
  <MouseTracker
    render={({ x, y }) => (
      <div>
        <h1>Move the mouse around!</h1>
        <p>The current mouse position is ({x}, {y})</p>
      </div>
    )}
  />
);

// å¤æ‚çš„Render Propsç¤ºä¾‹
const DataProvider = ({ url, render }) => {
  const [state, setState] = useState({
    data: null,
    loading: true,
    error: null,
  });
  
  useEffect(() => {
    fetch(url)
      .then(response => response.json())
      .then(data => setState({ data, loading: false, error: null }))
      .catch(error => setState({ data: null, loading: false, error }));
  }, [url]);
  
  return render(state);
};

// ä½¿ç”¨
const UserList = () => (
  <DataProvider
    url="/api/users"
    render={({ data, loading, error }) => {
      if (loading) return <div>Loading...</div>;
      if (error) return <div>Error: {error.message}</div>;
      return (
        <ul>
          {data.map(user => (
            <li key={user.id}>{user.name}</li>
          ))}
        </ul>
      );
    }}
  />
);

// Function as Childrenæ¨¡å¼
const Toggle = ({ children }) => {
  const [on, setOn] = useState(false);
  const toggle = () => setOn(!on);
  
  return children({ on, toggle });
};

// ä½¿ç”¨
const ToggleExample = () => (
  <Toggle>
    {({ on, toggle }) => (
      <div>
        <button onClick={toggle}>
          {on ? 'Turn off' : 'Turn on'}
        </button>
        {on && <div>The toggle is on!</div>}
      </div>
    )}
  </Toggle>
);
```

### è‡ªå®šä¹‰Hooksæ¨¡å¼

è‡ªå®šä¹‰Hooksè®©ä½ åœ¨ä¸å¢åŠ ç»„ä»¶çš„æƒ…å†µä¸‹å¤ç”¨çŠ¶æ€é€»è¾‘ã€‚

```jsx
// åŸºç¡€è‡ªå®šä¹‰Hook
const useCounter = (initialValue = 0) => {
  const [count, setCount] = useState(initialValue);
  
  const increment = useCallback(() => setCount(c => c + 1), []);
  const decrement = useCallback(() => setCount(c => c - 1), []);
  const reset = useCallback(() => setCount(initialValue), [initialValue]);
  
  return { count, increment, decrement, reset };
};

// å¤æ‚çš„è‡ªå®šä¹‰Hook
const useApi = (url, options = {}) => {
  const [state, setState] = useState({
    data: null,
    loading: true,
    error: null,
  });
  
  const fetchData = useCallback(async () => {
    try {
      setState(prev => ({ ...prev, loading: true }));
      const response = await fetch(url, options);
      const data = await response.json();
      setState({ data, loading: false, error: null });
    } catch (error) {
      setState({ data: null, loading: false, error });
    }
  }, [url, options]);
  
  useEffect(() => {
    fetchData();
  }, [fetchData]);
  
  return { ...state, refetch: fetchData };
};

// è¡¨å•ç®¡ç†Hook
const useForm = (initialValues, validationSchema) => {
  const [values, setValues] = useState(initialValues);
  const [errors, setErrors] = useState({});
  const [touched, setTouched] = useState({});
  
  const setValue = useCallback((name, value) => {
    setValues(prev => ({ ...prev, [name]: value }));
  }, []);
  
  const setFieldTouched = useCallback((name) => {
    setTouched(prev => ({ ...prev, [name]: true }));
  }, []);
  
  const validate = useCallback(() => {
    const newErrors = {};
    
    Object.keys(validationSchema).forEach(field => {
      const rules = validationSchema[field];
      const value = values[field];
      
      rules.forEach(rule => {
        if (!rule.test(value)) {
          newErrors[field] = rule.message;
        }
      });
    });
    
    setErrors(newErrors);
    return Object.keys(newErrors).length === 0;
  }, [values, validationSchema]);
  
  const handleChange = useCallback((e) => {
    const { name, value } = e.target;
    setValue(name, value);
  }, [setValue]);
  
  const handleBlur = useCallback((e) => {
    const { name } = e.target;
    setFieldTouched(name);
  }, [setFieldTouched]);
  
  const handleSubmit = useCallback((onSubmit) => (e) => {
    e.preventDefault();
    
    // æ ‡è®°æ‰€æœ‰å­—æ®µä¸ºå·²è§¦æ‘¸
    const allTouched = Object.keys(values).reduce((acc, key) => {
      acc[key] = true;
      return acc;
    }, {});
    setTouched(allTouched);
    
    if (validate()) {
      onSubmit(values);
    }
  }, [values, validate]);
  
  return {
    values,
    errors,
    touched,
    handleChange,
    handleBlur,
    handleSubmit,
    setValue,
    validate,
  };
};

// ä½¿ç”¨è‡ªå®šä¹‰Hook
const LoginForm = () => {
  const { values, errors, touched, handleChange, handleBlur, handleSubmit } = useForm(
    { email: '', password: '' },
    {
      email: [
        { test: (value) => value.length > 0, message: 'Email is required' },
        { test: (value) => /\S+@\S+\.\S+/.test(value), message: 'Email is invalid' },
      ],
      password: [
        { test: (value) => value.length >= 6, message: 'Password must be at least 6 characters' },
      ],
    }
  );
  
  const onSubmit = (data) => {
    console.log('Form submitted:', data);
  };
  
  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <div>
        <input
          name="email"
          type="email"
          value={values.email}
          onChange={handleChange}
          onBlur={handleBlur}
          placeholder="Email"
        />
        {touched.email && errors.email && (
          <div className="error">{errors.email}</div>
        )}
      </div>
      
      <div>
        <input
          name="password"
          type="password"
          value={values.password}
          onChange={handleChange}
          onBlur={handleBlur}
          placeholder="Password"
        />
        {touched.password && errors.password && (
          <div className="error">{errors.password}</div>
        )}
      </div>
      
      <button type="submit">Login</button>
    </form>
  );
};
```

### ç»„åˆvsç»§æ‰¿

Reactæ¨èä½¿ç”¨ç»„åˆè€Œéç»§æ‰¿æ¥å®ç°ç»„ä»¶é—´çš„ä»£ç å¤ç”¨ã€‚

```jsx
// ä½¿ç”¨ç»„åˆçš„å®¹å™¨ç»„ä»¶
const Card = ({ header, children, footer, className = '' }) => (
  <div className={`card ${className}`}>
    {header && <div className="card-header">{header}</div>}
    <div className="card-body">{children}</div>
    {footer && <div className="card-footer">{footer}</div>}
  </div>
);

// ç‰¹æ®Šç”¨é€”çš„Cardç»„ä»¶
const UserCard = ({ user, onEdit, onDelete }) => (
  <Card
    header={<h3>{user.name}</h3>}
    footer={
      <div className="actions">
        <button onClick={() => onEdit(user)}>Edit</button>
        <button onClick={() => onDelete(user.id)}>Delete</button>
      </div>
    }
    className="user-card"
  >
    <p>Email: {user.email}</p>
    <p>Role: {user.role}</p>
  </Card>
);

// ä½¿ç”¨æ’æ§½(slots)çš„æ¨¡å¼
const Dialog = ({ 
  title, 
  children, 
  actions, 
  isOpen, 
  onClose,
  size = 'medium' 
}) => {
  if (!isOpen) return null;
  
  return (
    <div className="dialog-overlay" onClick={onClose}>
      <div 
        className={`dialog dialog-${size}`}
        onClick={e => e.stopPropagation()}
      >
        <div className="dialog-header">
          <h2>{title}</h2>
          <button onClick={onClose}>Ã—</button>
        </div>
        
        <div className="dialog-content">
          {children}
        </div>
        
        {actions && (
          <div className="dialog-actions">
            {actions}
          </div>
        )}
      </div>
    </div>
  );
};

// ä½¿ç”¨Dialog
const ConfirmDialog = ({ isOpen, onClose, onConfirm, message }) => (
  <Dialog
    title="Confirm Action"
    isOpen={isOpen}
    onClose={onClose}
    actions={
      <>
        <button onClick={onClose}>Cancel</button>
        <button onClick={onConfirm} className="primary">Confirm</button>
      </>
    }
  >
    <p>{message}</p>
  </Dialog>
);

// ç»„åˆå¤šä¸ªç»„ä»¶çš„å¤æ‚ç¤ºä¾‹
const Layout = ({ 
  header, 
  sidebar, 
  children, 
  footer,
  sidebarCollapsed = false 
}) => (
  <div className="layout">
    {header && <header className="layout-header">{header}</header>}
    
    <div className="layout-main">
      {sidebar && (
        <aside className={`layout-sidebar ${sidebarCollapsed ? 'collapsed' : ''}`}>
          {sidebar}
        </aside>
      )}
      
      <main className="layout-content">
        {children}
      </main>
    </div>
    
    {footer && <footer className="layout-footer">{footer}</footer>}
  </div>
);

// ä½¿ç”¨Layout
const App = () => {
  const [sidebarCollapsed, setSidebarCollapsed] = useState(false);
  
  return (
    <Layout
      header={
        <AppHeader 
          onToggleSidebar={() => setSidebarCollapsed(!sidebarCollapsed)}
        />
      }
      sidebar={<Navigation />}
      footer={<AppFooter />}
      sidebarCollapsed={sidebarCollapsed}
    >
      <Routes>
        <Route path="/" element={<Dashboard />} />
        <Route path="/users" element={<UserList />} />
        <Route path="/settings" element={<Settings />} />
      </Routes>
    </Layout>
  );
};
```

### å—æ§vséå—æ§ç»„ä»¶

```jsx
// å—æ§ç»„ä»¶
const ControlledInput = ({ value, onChange, ...props }) => (
  <input value={value} onChange={onChange} {...props} />
);

// éå—æ§ç»„ä»¶
const UncontrolledInput = ({ defaultValue, ...props }) => {
  const ref = useRef();
  
  const getValue = () => ref.current.value;
  
  useImperativeHandle(props.ref, () => ({
    getValue,
    focus: () => ref.current.focus(),
  }));
  
  return <input ref={ref} defaultValue={defaultValue} {...props} />;
};

// æ··åˆæ¨¡å¼ - æ—¢å¯ä»¥å—æ§ä¹Ÿå¯ä»¥éå—æ§
const FlexibleInput = ({ 
  value: controlledValue, 
  defaultValue, 
  onChange,
  ...props 
}) => {
  const [internalValue, setInternalValue] = useState(defaultValue || '');
  const isControlled = controlledValue !== undefined;
  
  const value = isControlled ? controlledValue : internalValue;
  
  const handleChange = (e) => {
    const newValue = e.target.value;
    
    if (!isControlled) {
      setInternalValue(newValue);
    }
    
    onChange?.(e);
  };
  
  return <input value={value} onChange={handleChange} {...props} />;
};

// è‡ªå®šä¹‰Hookæ”¯æŒå—æ§/éå—æ§æ¨¡å¼
const useControllableState = (controlledValue, defaultValue, onChange) => {
  const [internalValue, setInternalValue] = useState(defaultValue);
  const isControlled = controlledValue !== undefined;
  
  const value = isControlled ? controlledValue : internalValue;
  
  const setValue = (newValue) => {
    if (!isControlled) {
      setInternalValue(newValue);
    }
    onChange?.(newValue);
  };
  
  return [value, setValue];
};

// ä½¿ç”¨è‡ªå®šä¹‰Hookçš„ç»„ä»¶
const Toggle = ({ checked: controlledChecked, defaultChecked, onChange }) => {
  const [checked, setChecked] = useControllableState(
    controlledChecked,
    defaultChecked,
    onChange
  );
  
  return (
    <button
      className={`toggle ${checked ? 'checked' : ''}`}
      onClick={() => setChecked(!checked)}
    >
      {checked ? 'ON' : 'OFF'}
    </button>
  );
};
```

---

## é«˜çº§æ¨¡å¼

### æä¾›è€…æ¨¡å¼

æä¾›è€…æ¨¡å¼ä½¿ç”¨React Contextåœ¨ç»„ä»¶æ ‘ä¸­å…±äº«æ•°æ®ã€‚

```jsx
// ä¸»é¢˜æä¾›è€…
const ThemeContext = createContext();

const ThemeProvider = ({ children }) => {
  const [theme, setTheme] = useState('light');
  
  const toggleTheme = () => {
    setTheme(prev => prev === 'light' ? 'dark' : 'light');
  };
  
  const value = {
    theme,
    setTheme,
    toggleTheme,
    colors: theme === 'light' ? lightColors : darkColors,
  };
  
  return (
    <ThemeContext.Provider value={value}>
      <div className={`app-theme-${theme}`}>
        {children}
      </div>
    </ThemeContext.Provider>
  );
};

const useTheme = () => {
  const context = useContext(ThemeContext);
  if (!context) {
    throw new Error('useTheme must be used within ThemeProvider');
  }
  return context;
};

// è®¤è¯æä¾›è€…
const AuthContext = createContext();

const AuthProvider = ({ children }) => {
  const [user, setUser] = useState(null);
  const [loading, setLoading] = useState(true);
  
  useEffect(() => {
    // æ£€æŸ¥ç™»å½•çŠ¶æ€
    checkAuthStatus()
      .then(setUser)
      .finally(() => setLoading(false));
  }, []);
  
  const login = async (credentials) => {
    const user = await authService.login(credentials);
    setUser(user);
    return user;
  };
  
  const logout = () => {
    authService.logout();
    setUser(null);
  };
  
  const value = {
    user,
    loading,
    isAuthenticated: !!user,
    login,
    logout,
  };
  
  return (
    <AuthContext.Provider value={value}>
      {children}
    </AuthContext.Provider>
  );
};

const useAuth = () => {
  const context = useContext(AuthContext);
  if (!context) {
    throw new Error('useAuth must be used within AuthProvider');
  }
  return context;
};

// ç»„åˆå¤šä¸ªæä¾›è€…
const AppProviders = ({ children }) => (
  <ThemeProvider>
    <AuthProvider>
      <Router>
        <QueryClient>
          {children}
        </QueryClient>
      </Router>
    </AuthProvider>
  </ThemeProvider>
);
```

### å¤åˆç»„ä»¶æ¨¡å¼

å¤åˆç»„ä»¶æ¨¡å¼åˆ›å»ºä¸€ç»„ååŒå·¥ä½œçš„ç»„ä»¶ã€‚

```jsx
// Accordionå¤åˆç»„ä»¶
const AccordionContext = createContext();

const Accordion = ({ children, allowMultiple = false }) => {
  const [openItems, setOpenItems] = useState(new Set());
  
  const toggle = (item) => {
    setOpenItems(prev => {
      const newSet = new Set(prev);
      if (newSet.has(item)) {
        newSet.delete(item);
      } else {
        if (!allowMultiple) {
          newSet.clear();
        }
        newSet.add(item);
      }
      return newSet;
    });
  };
  
  const value = {
    openItems,
    toggle,
    isOpen: (item) => openItems.has(item),
  };
  
  return (
    <AccordionContext.Provider value={value}>
      <div className="accordion">{children}</div>
    </AccordionContext.Provider>
  );
};

const AccordionItem = ({ children, value }) => {
  const { isOpen } = useContext(AccordionContext);
  
  return (
    <div className={`accordion-item ${isOpen(value) ? 'open' : ''}`}>
      {children}
    </div>
  );
};

const AccordionHeader = ({ children, value }) => {
  const { toggle } = useContext(AccordionContext);
  
  return (
    <button 
      className="accordion-header"
      onClick={() => toggle(value)}
    >
      {children}
    </button>
  );
};

const AccordionPanel = ({ children, value }) => {
  const { isOpen } = useContext(AccordionContext);
  
  if (!isOpen(value)) return null;
  
  return (
    <div className="accordion-panel">
      {children}
    </div>
  );
};

// ä½¿ç”¨å¤åˆç»„ä»¶
const FAQ = () => (
  <Accordion allowMultiple>
    <AccordionItem value="item1">
      <AccordionHeader value="item1">
        What is React?
      </AccordionHeader>
      <AccordionPanel value="item1">
        React is a JavaScript library for building user interfaces.
      </AccordionPanel>
    </AccordionItem>
    
    <AccordionItem value="item2">
      <AccordionHeader value="item2">
        How do I learn React?
      </AccordionHeader>
      <AccordionPanel value="item2">
        Start with the official React documentation and build projects.
      </AccordionPanel>
    </AccordionItem>
  </Accordion>
);

// æ›´å¤æ‚çš„å¤åˆç»„ä»¶ - Dropdown
const DropdownContext = createContext();

const Dropdown = ({ children, onSelect }) => {
  const [isOpen, setIsOpen] = useState(false);
  const [selectedValue, setSelectedValue] = useState(null);
  
  const select = (value) => {
    setSelectedValue(value);
    setIsOpen(false);
    onSelect?.(value);
  };
  
  const value = {
    isOpen,
    setIsOpen,
    selectedValue,
    select,
  };
  
  return (
    <DropdownContext.Provider value={value}>
      <div className="dropdown">{children}</div>
    </DropdownContext.Provider>
  );
};

const DropdownTrigger = ({ children }) => {
  const { isOpen, setIsOpen, selectedValue } = useContext(DropdownContext);
  
  return (
    <button 
      className="dropdown-trigger"
      onClick={() => setIsOpen(!isOpen)}
    >
      {selectedValue || children}
    </button>
  );
};

const DropdownMenu = ({ children }) => {
  const { isOpen } = useContext(DropdownContext);
  
  if (!isOpen) return null;
  
  return (
    <div className="dropdown-menu">
      {children}
    </div>
  );
};

const DropdownItem = ({ children, value }) => {
  const { select } = useContext(DropdownContext);
  
  return (
    <div 
      className="dropdown-item"
      onClick={() => select(value)}
    >
      {children}
    </div>
  );
};
```

### çŠ¶æ€ç¼©å‡å™¨æ¨¡å¼

ä½¿ç”¨useReducerç®¡ç†å¤æ‚çŠ¶æ€é€»è¾‘ã€‚

```jsx
// TodoçŠ¶æ€ç®¡ç†
const todoReducer = (state, action) => {
  switch (action.type) {
    case 'ADD_TODO':
      return {
        ...state,
        todos: [...state.todos, {
          id: Date.now(),
          text: action.payload,
          completed: false,
        }],
      };
      
    case 'TOGGLE_TODO':
      return {
        ...state,
        todos: state.todos.map(todo =>
          todo.id === action.payload
            ? { ...todo, completed: !todo.completed }
            : todo
        ),
      };
      
    case 'DELETE_TODO':
      return {
        ...state,
        todos: state.todos.filter(todo => todo.id !== action.payload),
      };
      
    case 'SET_FILTER':
      return {
        ...state,
        filter: action.payload,
      };
      
    case 'SET_LOADING':
      return {
        ...state,
        loading: action.payload,
      };
      
    default:
      return state;
  }
};

const initialState = {
  todos: [],
  filter: 'all',
  loading: false,
};

// è‡ªå®šä¹‰Hookå°è£…çŠ¶æ€é€»è¾‘
const useTodos = () => {
  const [state, dispatch] = useReducer(todoReducer, initialState);
  
  const addTodo = (text) => {
    dispatch({ type: 'ADD_TODO', payload: text });
  };
  
  const toggleTodo = (id) => {
    dispatch({ type: 'TOGGLE_TODO', payload: id });
  };
  
  const deleteTodo = (id) => {
    dispatch({ type: 'DELETE_TODO', payload: id });
  };
  
  const setFilter = (filter) => {
    dispatch({ type: 'SET_FILTER', payload: filter });
  };
  
  const filteredTodos = useMemo(() => {
    switch (state.filter) {
      case 'completed':
        return state.todos.filter(todo => todo.completed);
      case 'active':
        return state.todos.filter(todo => !todo.completed);
      default:
        return state.todos;
    }
  }, [state.todos, state.filter]);
  
  return {
    ...state,
    filteredTodos,
    addTodo,
    toggleTodo,
    deleteTodo,
    setFilter,
  };
};

// å¤æ‚è¡¨å•çŠ¶æ€ç®¡ç†
const formReducer = (state, action) => {
  switch (action.type) {
    case 'SET_FIELD':
      return {
        ...state,
        values: {
          ...state.values,
          [action.field]: action.value,
        },
        errors: {
          ...state.errors,
          [action.field]: null, // æ¸…é™¤é”™è¯¯
        },
      };
      
    case 'SET_ERRORS':
      return {
        ...state,
        errors: action.payload,
      };
      
    case 'SET_TOUCHED':
      return {
        ...state,
        touched: {
          ...state.touched,
          [action.field]: true,
        },
      };
      
    case 'SET_SUBMITTING':
      return {
        ...state,
        isSubmitting: action.payload,
      };
      
    case 'RESET_FORM':
      return action.payload || {
        values: {},
        errors: {},
        touched: {},
        isSubmitting: false,
      };
      
    default:
      return state;
  }
};

const useFormReducer = (initialValues = {}) => {
  const [state, dispatch] = useReducer(formReducer, {
    values: initialValues,
    errors: {},
    touched: {},
    isSubmitting: false,
  });
  
  const setField = (field, value) => {
    dispatch({ type: 'SET_FIELD', field, value });
  };
  
  const setErrors = (errors) => {
    dispatch({ type: 'SET_ERRORS', payload: errors });
  };
  
  const setTouched = (field) => {
    dispatch({ type: 'SET_TOUCHED', field });
  };
  
  const setSubmitting = (isSubmitting) => {
    dispatch({ type: 'SET_SUBMITTING', payload: isSubmitting });
  };
  
  const resetForm = (newValues) => {
    dispatch({ type: 'RESET_FORM', payload: newValues });
  };
  
  return {
    ...state,
    setField,
    setErrors,
    setTouched,
    setSubmitting,
    resetForm,
  };
};
```

---

## æœ€ä½³å®è·µ

### 1. é€‰æ‹©åˆé€‚çš„æ¨¡å¼

```jsx
// æ ¹æ®éœ€æ±‚é€‰æ‹©æ¨¡å¼
const ComponentDecision = () => {
  // ç®€å•çš„é€»è¾‘å¤ç”¨ -> è‡ªå®šä¹‰Hook
  const { count, increment } = useCounter();
  
  // éœ€è¦è®¿é—®ç»„ä»¶å®ä¾‹ -> Render Props
  const mousePosition = (
    <MouseTracker render={({ x, y }) => `${x}, ${y}`} />
  );
  
  // éœ€è¦åŒ…è£…å¤šä¸ªç»„ä»¶ -> HOC
  const EnhancedComponent = withAuth(MyComponent);
  
  // å¤æ‚çŠ¶æ€ç®¡ç† -> Context + Reducer
  const todoApp = <TodoProvider><TodoApp /></TodoProvider>;
  
  return null;
};
```

### 2. æ€§èƒ½ä¼˜åŒ–

```jsx
// ä½¿ç”¨React.memoä¼˜åŒ–
const ExpensiveComponent = React.memo(({ data }) => {
  return <div>{/* å¤æ‚æ¸²æŸ“é€»è¾‘ */}</div>;
}, (prevProps, nextProps) => {
  // è‡ªå®šä¹‰æ¯”è¾ƒé€»è¾‘
  return prevProps.data.id === nextProps.data.id;
});

// ä½¿ç”¨useMemoç¼“å­˜è®¡ç®—ç»“æœ
const DataProcessor = ({ items }) => {
  const processedData = useMemo(() => {
    return items
      .filter(item => item.active)
      .sort((a, b) => a.priority - b.priority)
      .map(item => ({
        ...item,
        displayName: `${item.name} (${item.category})`,
      }));
  }, [items]);
  
  return <ItemList items={processedData} />;
};

// ä½¿ç”¨useCallbackç¼“å­˜å‡½æ•°
const ListContainer = ({ items, onUpdate }) => {
  const handleItemClick = useCallback((item) => {
    onUpdate(item.id, { ...item, clicked: true });
  }, [onUpdate]);
  
  return (
    <div>
      {items.map(item => (
        <Item 
          key={item.id} 
          item={item} 
          onClick={handleItemClick}
        />
      ))}
    </div>
  );
};
```

### 3. é”™è¯¯å¤„ç†æ¨¡å¼

```jsx
// é”™è¯¯è¾¹ç•Œ
class ErrorBoundary extends Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false, error: null };
  }
  
  static getDerivedStateFromError(error) {
    return { hasError: true, error };
  }
  
  componentDidCatch(error, errorInfo) {
    console.error('Error caught by boundary:', error, errorInfo);
    // å‘é€é”™è¯¯æŠ¥å‘Š
  }
  
  render() {
    if (this.state.hasError) {
      return this.props.fallback || <div>Something went wrong.</div>;
    }
    
    return this.props.children;
  }
}

// ä½¿ç”¨é”™è¯¯è¾¹ç•Œ
const App = () => (
  <ErrorBoundary fallback={<ErrorFallback />}>
    <Router>
      <Routes>
        <Route path="/" element={
          <ErrorBoundary fallback={<PageError />}>
            <HomePage />
          </ErrorBoundary>
        } />
      </Routes>
    </Router>
  </ErrorBoundary>
);

// å¼‚æ­¥é”™è¯¯å¤„ç†Hook
const useAsyncError = () => {
  const [, setError] = useState();
  return useCallback((error) => {
    setError(() => {
      throw error;
    });
  }, []);
};

// å®‰å…¨çš„å¼‚æ­¥ç»„ä»¶
const SafeAsyncComponent = () => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(false);
  const throwError = useAsyncError();
  
  const fetchData = async () => {
    try {
      setLoading(true);
      const result = await api.getData();
      setData(result);
    } catch (error) {
      throwError(error);
    } finally {
      setLoading(false);
    }
  };
  
  return (
    <div>
      {loading && <div>Loading...</div>}
      {data && <DataDisplay data={data} />}
      <button onClick={fetchData}>Fetch Data</button>
    </div>
  );
};
```

### 4. æµ‹è¯•å‹å¥½çš„æ¨¡å¼

```jsx
// ä¾èµ–æ³¨å…¥æ¨¡å¼ä¾¿äºæµ‹è¯•
const ApiContext = createContext();

const ApiProvider = ({ children, apiClient = defaultApiClient }) => (
  <ApiContext.Provider value={apiClient}>
    {children}
  </ApiContext.Provider>
);

const useApi = () => {
  const api = useContext(ApiContext);
  if (!api) {
    throw new Error('useApi must be used within ApiProvider');
  }
  return api;
};

// æµ‹è¯•æ—¶å¯ä»¥æ³¨å…¥mock API
const TestWrapper = ({ children }) => (
  <ApiProvider apiClient={mockApiClient}>
    {children}
  </ApiProvider>
);

// å¯æµ‹è¯•çš„ç»„ä»¶
const UserProfile = ({ userId }) => {
  const api = useApi();
  const [user, setUser] = useState(null);
  
  useEffect(() => {
    api.getUser(userId).then(setUser);
  }, [api, userId]);
  
  if (!user) return <div>Loading...</div>;
  
  return (
    <div data-testid="user-profile">
      <h1>{user.name}</h1>
      <p>{user.email}</p>
    </div>
  );
};
```

### 5. ä»£ç ç»„ç»‡æ¨¡å¼

```jsx
// ç‰¹æ€§æ–‡ä»¶å¤¹ç»“æ„
features/
  auth/
    components/
      LoginForm.jsx
      SignupForm.jsx
    hooks/
      useAuth.js
      useLogin.js
    services/
      authService.js
    context/
      AuthContext.js
    index.js
  users/
    components/
    hooks/
    services/
    context/
    index.js

// å¯¼å…¥å¯¼å‡ºæ¨¡å¼
// features/auth/index.js
export { AuthProvider, useAuth } from './context/AuthContext';
export { LoginForm, SignupForm } from './components';
export { useLogin, useSignup } from './hooks';

// ä½¿ç”¨
import { AuthProvider, LoginForm } from 'features/auth';
```

---

## æ€»ç»“ä¸èµ„æº

### è®¾è®¡æ¨¡å¼é€‰æ‹©æŒ‡å—

| åœºæ™¯ | æ¨èæ¨¡å¼ | åŸå›  |
|------|----------|------|
| ç®€å•çŠ¶æ€é€»è¾‘å¤ç”¨ | è‡ªå®šä¹‰Hook | ç®€æ´ã€æ˜“æµ‹è¯• |
| ç»„ä»¶åŠŸèƒ½å¢å¼º | HOC | å¯ç»„åˆã€å¯é‡ç”¨ |
| åŠ¨æ€æ¸²æŸ“é€»è¾‘ | Render Props | çµæ´»æ€§é«˜ |
| è·¨ç»„ä»¶æ•°æ®å…±äº« | Context + Provider | é¿å…prop drilling |
| å¤æ‚çŠ¶æ€ç®¡ç† | Reduceræ¨¡å¼ | å¯é¢„æµ‹ã€æ˜“è°ƒè¯• |
| ç»„ä»¶åä½œ | å¤åˆç»„ä»¶ | å…³æ³¨ç‚¹åˆ†ç¦» |

### è¿›é˜¶å­¦ä¹ èµ„æº

1. **å®˜æ–¹æ–‡æ¡£**
   - [React Patterns](https://reactpatterns.com/)
   - [React Beta Docs](https://beta.reactjs.org/)

2. **æ¨èä¹¦ç±**
   - "Design Patterns" by Gang of Four
   - "React Design Patterns and Best Practices"
   - "Advanced React Patterns"

3. **å®è·µé¡¹ç›®**
   - æ„å»ºç»„ä»¶åº“
   - çŠ¶æ€ç®¡ç†åº“
   - å¤æ‚è¡¨å•ç³»ç»Ÿ

### æœ€åçš„å»ºè®®

1. **å¾ªåºæ¸è¿›**: ä»ç®€å•æ¨¡å¼å¼€å§‹ï¼Œé€æ­¥æŒæ¡å¤æ‚æ¨¡å¼
2. **å®è·µä¸ºç‹**: åœ¨å®é™…é¡¹ç›®ä¸­åº”ç”¨è¿™äº›æ¨¡å¼
3. **æ€§èƒ½ä¼˜å…ˆ**: å§‹ç»ˆè€ƒè™‘æ¨¡å¼å¯¹æ€§èƒ½çš„å½±å“
4. **å›¢é˜Ÿåä½œ**: ç¡®ä¿å›¢é˜Ÿæˆå‘˜éƒ½ç†è§£ä½¿ç”¨çš„æ¨¡å¼
5. **ä¿æŒæ›´æ–°**: å…³æ³¨Reactç”Ÿæ€çš„æœ€æ–°å‘å±•

è®¾è®¡æ¨¡å¼ä¸æ˜¯é“¶å¼¹ï¼Œä½†å®ƒä»¬æ˜¯æ„å»ºå¯ç»´æŠ¤ã€å¯æ‰©å±•Reactåº”ç”¨çš„é‡è¦å·¥å…·ã€‚é€‰æ‹©åˆé€‚çš„æ¨¡å¼ï¼Œå¹¶æ ¹æ®é¡¹ç›®éœ€æ±‚çµæ´»åº”ç”¨ï¼Œå°†å¤§å¤§æå‡ä½ çš„å¼€å‘æ•ˆç‡å’Œä»£ç è´¨é‡ã€‚

---

*è¿™ä»½æ•™ç¨‹æ¶µç›–äº†Reactå¼€å‘ä¸­æœ€é‡è¦çš„è®¾è®¡æ¨¡å¼ã€‚æŒç»­å®è·µå’Œå­¦ä¹ å°†å¸®åŠ©ä½ æˆä¸ºæ›´å¥½çš„Reactå¼€å‘è€…ã€‚*